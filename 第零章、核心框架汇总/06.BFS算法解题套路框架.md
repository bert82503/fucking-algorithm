

BFS 算法解题套路框架
======
> https://labuladong.github.io/algo/1/7/


读完本文，你不仅学会了**算法套路**，还可以顺便解决如下题目：

[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

[752. 打开转盘锁](https://leetcode.cn/problems/open-the-lock/)

**-----------**

后台有很多人问起 BFS 和 DFS 的框架，今天就来说说吧。

首先，你要说我没写过 BFS 框架，这话没错，今天写个框架你背住就完事儿了。
但要是说没写过 DFS 框架，那你还真是说错了，其实 **DFS 算法就是回溯算法**，
我们前文 [回溯算法框架套路详解](https://labuladong.github.io/algo/4/29/103/) 
就写过了，而且写得不是一般得好，建议好好复习，嘿嘿嘿~

BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。
一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。

**BFS 相对 DFS 的最主要的区别**是：
**BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多**，
至于为什么，我们后面介绍了框架就很容易看出来了。

本文就由浅入深写两道 BFS 的典型题目，分别是「二叉树的最小高度」和「打开密码锁的最少步数」，
手把手教你怎么写 BFS 算法。


# 一、算法框架



